class StateAndRender extends MC {
  constructor() {
    super();
    this.lessonTextSpanState = MC.uState(
      "Какой-то div",
      "test_state_mc-lesson_stateAmdRender"
    );
  }

  render() {
    return container(
      $("<div>").append(
        articleWrapper(
          sectionTitle("Состояние и Рендер"),
          heading1("# Что такое состояние в MC"),
          textP(
            `Исторически, начиная с версий v4–v6, функциональные контейнеры и классовые компоненты в MC рассматривались отдельно. 
            Каждый из подходов имел собственный раздел документации, со своими примерами и нюансами использования.`
          ),
          textP(
            `В версии v7 структура документации была пересмотрена: разделы объединены в один — <strong>«Состояние и рендеринг»</strong>. 
            Это решение оказалось более логичным, ведь механизм рендеринга в MC по сути един, 
            а различия между функциональными и классовыми подходами касаются лишь способа объявления и управления состоянием.`
          ),
          spacer("10px"),
          infoBox(
            "Получается...",
            `Теперь оба подхода рассматриваются вместе. Это упрощает восприятие концепций и позволяет лучше понять, 
            как MC работает с состоянием, реактивностью и перерисовкой интерфейса в целом.`
          ),
          heading2("# Использование контейнеров функций"),
          textP(
            `Функциональные контейнеры в MC — это простота реактивного подхода. 
            Они позволяют описывать логику и состояние компонента через простую функцию, 
            при этом сохраняя полный контроль над реакциями и обновлениями.`
          ),
          textP(
            `В отличие от классовых компонентов, где состояние чаще описывается в виде свойств экземпляра, 
            функциональные контейнеры используют внутреннюю систему подписок MC. 
            Это делает их особенно удобными для создания лёгких, локальных элементов интерфейса.`
          ),

          $("<div>")
            .css({
              display: "flex",
              "justify-content": "space-around",
            })
            .append(
              codeBlock(
                "Пример простого функционального контейнера МС",
                "Тут мы просто отображаем текст, пока оставим реактивность.",
                `// Создадим глобальный объект состояния.
const textSpanState = MC.uState('text_state_value', 'init_state');

$.MC(() => {
    // Все что он делает возвращает вёрстку которую вы напишите.
    return $('<div>').css({ backgroundColor: '#000', padding: '5px' }).append(
            $('<span>').text('Какой-то span'),
        )
}, [textSpanState])`
              ),
              card([
                textMuted(
                  "Контейнер действительно отрисовал наш <span>, как ожидалось:"
                ),
                spacer(),
                $.MC(
                  () => {
                    // Все что он делает возвращает вёрстку которую вы напишите.
                    return $("<div>")
                      .css({ backgroundColor: "#000", padding: "5px" })
                      .append($("<span>").text("Какой-то span"));
                  },
                  [this.lessonTextSpanState],
                  "fn_lesson_function_mc-lesson_stateAmdRender"
                ),
                spacer(),
                textMuted(
                  "Но на практике такое использование функционального контейнера не несёт особого смысла."
                ),
                textMuted(
                  "Он пока что просто выводит разметку, не реагируя на состояние или изменения данных."
                ),
              ]).css({ marginTop: "2rem" })
            ),
          spacer(),

          textP(
            `Чтобы функциональные контейнеры действительно имели смысл, 
  им нужно с чем-то работать — с изменяющимися данными. 
  Именно для этого в MC существует понятие - <strong>состояние</strong>.`
          ),

          spacer("10px"),

          infoBox(
            "Что же такое состояние в MC?",
            `<strong>Состояние (State)</strong> — это реактивное значение, хранящее данные компонента. 
  При его изменении MC автоматически вызывает обновление всех контейнеров, 
  которые используют это состояние. Таким образом, интерфейс всегда отражает актуальные данные.`
          ),

          spacer("10px"),

          textP(
            `Состояния могут быть как глобальными — общими для разных частей приложения, 
  так и локальными — существующими только внутри одного компонента (Локальные состояния очень мощная функция МС, которую мы рассмотрим позже).`
          ),

          spacer("10px"),

          textP(`В MC они создаются через функцию 
            \`<strong>MC.uState(initialValue, key)</strong>\`,
            где \`<strong>key</strong>\` — уникальный идентификатор (ниже введётся объяснение зачем они нужны), 
  а \`<strong>initialValue</strong>\` — начальное значение.`),

          spacer("10px"),

          textP(
            `Давайте теперь посмотрим, как использовать это состояние для обновления нашего интерфейса:`
          ),

          $("<div>")
            .css({
              display: "flex",
              "justify-content": "space-around",
            })
            .append(
              codeBlock(
                "Пример простого функционального контейнера МС",
                "Тут мы поменяем текст в div, который пользователь пожелает ввести в div",
                `// Создадим глобальный объект состояния.
const textDivState = MC.uState('Какой-то div', 'init_state');

// теперь получим значение состояния. Обратите внимание, что это массив!
$.MC(([textDiv]) => {

return $("<div>")
    .css({ backgroundColor: "#000", padding: "5px" })
    .append(
        // тут мы используем textDiv как начальное значение текста в div
        // и сразу тут мы можем проверить, пустое ли значение в textDiv ?
        $("<div>").text(textDiv ? textDiv : 'Нет текста'),

        // тут мы используем textDiv как начальное значение текста в input
        $('<input>').val(textDiv).on('input', (e) => {
            // обратите внимание, что мы меняем непосредственно сам textDivState
            textDivState.set(e.target.value);
        })
    );
},[textDivState]);`
              ),
              card([
                textMuted(
                  "Теперь мы можем попробовать изменить значение input:"
                ),
                spacer(),
                $.MC(([lessonTextSpanState]) => {
                    // Все что он делает возвращает вёрстку которую вы напишите.
                    return $("<div>")
                      .css({ backgroundColor: "#000", padding: "5px" })
                      .append(
                        $("<div>").text(
                          lessonTextSpanState
                            ? lessonTextSpanState
                            : "Нет текста"
                        ),

                        $("<input>")
                          .attr("id", "lesson_StateAndRender_part_two-inpt")
                          .css({ color: "#000" })
                          .attr({ 'value': lessonTextSpanState })
                        //   .val(lessonTextSpanState)
                          .on("input", (e) => {
                            this.lessonTextSpanState.set(e.target.value);
                          })
                      );
                  },
                  [this.lessonTextSpanState],
                  "fn_lesson_function_mc-lesson_stateAmdRender_part_two"
                ),
                spacer(),
                textMuted(
                  "Теперь при изменении значения в input обновляется и span."
                ),
                textMuted(
                    'Можно увидеть как контейнер реагирует на состояние.'
                ),
                textMuted(
                  "MC автоматически обновляет интерфейс при изменении данных:"
                ),
                heading3('Без прямого вмешательства в DOM.')
              ]).css({ marginTop: "2rem" })
            ),
          spacer()
          // wrap appended
        )
      )
    );
  }
}
