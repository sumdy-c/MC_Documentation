class StateAndRender extends MC {
  constructor() {
    super();
    this.lessonTextSpanState = MC.uState(
      "Какой-то div",
      "test_state_mc-lesson_stateAmdRender"
    );
  }

  render() {
    return container(
      $("<div>").append(
        articleWrapper(
          sectionTitle("Состояние и Рендер"),
          heading1("# Что такое состояние в MC"),
          textP(
            `Исторически, начиная с версий v4–v6, функциональные контейнеры и классовые компоненты в MC рассматривались отдельно. 
            Каждый из подходов имел собственный раздел документации, со своими примерами и нюансами использования.`
          ),
          textP(
            `В версии v7 структура документации была пересмотрена: разделы объединены в один — <strong>«Состояние и рендеринг»</strong>. 
            Это решение оказалось более логичным, ведь механизм рендеринга в MC по сути един, 
            а различия между функциональными и классовыми подходами касаются лишь способа объявления и управления состоянием.`
          ),
          spacer("10px"),
          infoBox(
            "Получается...",
            `Теперь оба подхода рассматриваются вместе. Это упрощает восприятие концепций и позволяет лучше понять, 
            как MC работает с состоянием, реактивностью и перерисовкой интерфейса в целом.`
          ),

          heading2(
            "# Глобальное состояние | Начало исследования функциональных контейнеров"
          ),

          textP(
            `Функциональные контейнеры в MC — это простота реактивного подхода. 
            Они позволяют описывать логику и состояние компонента через простую функцию, 
            при этом сохраняя полный контроль над реакциями и обновлениями.`
          ),
          textP(
            `В отличие от классовых компонентов, где состояние чаще описывается в виде свойств экземпляра, 
            функциональные контейнеры используют внутреннюю систему подписок MC. 
            Это делает их особенно удобными для создания лёгких, локальных элементов интерфейса.`
          ),

          $("<div>")
            .css({
              display: "flex",
              "justify-content": "space-around",
            })
            .append(
              codeBlock(
                "Пример простого функционального контейнера МС",
                "Тут мы просто отображаем текст, пока оставим реактивность.",
                `// Создадим глобальный объект состояния.
const textSpanState = MC.uState('text_state_value', 'init_state');

$.MC(() => {
    // Все что он делает возвращает вёрстку которую вы напишите.
    return $('<div>').css({ backgroundColor: '#000', padding: '5px' }).append(
            $('<span>').text('Какой-то span'),
        )
}, [textSpanState])`
              ),
              card([
                textMuted(
                  "Контейнер действительно отрисовал наш <span>, как ожидалось:"
                ),
                spacer(),
                $.MC(
                  () => {
                    // Все что он делает возвращает вёрстку которую вы напишите.
                    return $("<div>")
                      .css({ backgroundColor: "#000", padding: "5px" })
                      .append($("<span>").text("Какой-то span"));
                  },
                  [this.lessonTextSpanState],
                  "fn_lesson_function_mc-lesson_stateAmdRender"
                ),
                spacer(),
                textMuted(
                  "Но на практике такое использование функционального контейнера не несёт особого смысла."
                ),
                textMuted(
                  "Он пока что просто выводит разметку, не реагируя на состояние или изменения данных."
                ),
              ]).css({ marginTop: "2rem" })
            ),
          spacer(),

          textP(
            `Чтобы функциональные контейнеры действительно имели смысл, 
  им нужно с чем-то работать — с изменяющимися данными. 
  Именно для этого в MC существует понятие - <strong>состояние</strong>.`
          ),

          spacer("10px"),

          infoBox(
            "Что же такое состояние в MC?",
            `<strong>Состояние (State)</strong> — это реактивное значение, хранящее данные компонента. 
  При его изменении MC автоматически вызывает обновление всех контейнеров, 
  которые используют это состояние. Таким образом, интерфейс всегда отражает актуальные данные.`
          ),

          spacer("10px"),

          textP(
            `Состояния могут быть как глобальными — общими для разных частей приложения, 
  так и локальными — существующими только внутри одного компонента (Локальные состояния очень мощная функция МС, которую мы рассмотрим позже).`
          ),

          spacer("10px"),

          textP(`В MC они создаются через функцию 
            \`<strong>MC.uState(initialValue, key)</strong>\`,
            где \`<strong>key</strong>\` — уникальный идентификатор (ниже введётся объяснение зачем они нужны), 
  а \`<strong>initialValue</strong>\` — начальное значение.`),

          spacer("10px"),

          textP(
            `Давайте теперь посмотрим, как использовать это состояние для обновления нашего интерфейса:`
          ),

          $("<div>")
            .css({
              display: "flex",
              "justify-content": "space-around",
            })
            .append(
              codeBlock(
                "Пример простого функционального контейнера МС",
                "Тут мы поменяем текст в div, который пользователь пожелает ввести в div",
                `// Создадим глобальный объект состояния.
const textDivState = MC.uState('Какой-то div', 'init_state');

// теперь получим значение состояния. Обратите внимание, что это массив!
$.MC(([textDiv]) => {

return $("<div>")
    .css({ backgroundColor: "#000", padding: "5px" })
    .append(
        // тут мы используем textDiv как начальное значение текста в div
        // и сразу тут мы можем проверить, пустое ли значение в textDiv ?
        $("<div>").text(textDiv ? textDiv : 'Нет текста'),

        // тут мы используем textDiv как начальное значение текста в input
        $('<input>').val(textDiv).on('input', (e) => {
            // обратите внимание, что мы меняем непосредственно сам textDivState
            textDivState.set(e.target.value);
        })
    );
},[textDivState]);`
              ),
              card([
                textMuted(
                  "Теперь мы можем попробовать изменить значение input:"
                ),
                spacer(),
                $.MC(
                  ([lessonTextSpanState]) => {
                    // Все что он делает возвращает вёрстку которую вы напишите.
                    return $("<div>")
                      .css({ backgroundColor: "#000", padding: "5px" })
                      .append(
                        $("<div>").text(
                          lessonTextSpanState
                            ? lessonTextSpanState
                            : "Нет текста"
                        ),

                        $("<input>")
                          .attr("id", "lesson_StateAndRender_part_two-inpt")
                          .css({ color: "#000" })
                          .attr({ value: lessonTextSpanState })
                          //   .val(lessonTextSpanState)
                          .on("input", (e) => {
                            this.lessonTextSpanState.set(e.target.value);
                          })
                      );
                  },
                  [this.lessonTextSpanState],
                  "fn_lesson_function_mc-lesson_stateAmdRender_part_two"
                ),
                spacer(),
                textMuted(
                  "Теперь при изменении значения в input обновляется и span."
                ),
                textMuted(
                  "Можно увидеть как контейнер реагирует на состояние."
                ),
                textMuted(
                  "MC автоматически обновляет интерфейс при изменении данных:"
                ),
                heading3("Без прямого вмешательства в DOM."),
              ]).css({ marginTop: "2rem" })
            ),
          spacer(),
          textP(
            `Сейчас мы разобрали один из самых простых случаев применения Micro Component. 
  На практике функциональные контейнеры обладают куда большей гибкостью и возможностями. 
  Для нас сейчас важно понять базовый принцип: <strong>состояние — это основа реактивности MC</strong>. 
  Мы только что познакомились с одной из его форм — <strong>глобальным состоянием</strong>.`
          ),

          spacer("10px"),

          infoBox(
            "Глобальное состояние ",
            ` — это объект данных, доступный из любой части приложения в пределах страницы. 
  Такое состояние можно получить и использовать в любом контейнере или компоненте, просто указав тот же ключ.  
  Это позволяет связывать между собой разрозненные элементы интерфейса, делая обновления данных централизованными и синхронными.`
          ),

          spacer("10px"),

          textP(
            `В отличие от локального состояния, глобальное может быть прочитано и изменено из любого места — 
  например, из другой функции, модуля или даже отдельного виджета. 
  Локальное же состояние живёт только внутри своего контейнера и не может быть «привязано» к другим элементам. Но на него мы посмотрим когда будем изучать классовые компоненты.`
          ),

          heading2(
            "? Необязательный блок | Углублённое исследование работы состояния"
          ),
          spacer("10px"),

          textMuted(`⚙️ Этот раздел не обязателен к изучению, однако он будет особенно полезен тем, кто хочет глубже понять, как Micro Component управляет состоянием на уровне внутренней архитектуры. 
Здесь мы разбираем класс MCState — основу системы управления состоянием, обеспечивающую реактивность, оптимизацию и согласованность данных.`),

          spacer("10px"),

          infoBox(
            `💡 MCState`,
            `внутренняя сущность, описывающая текущее значение состояния и все его связи. 
Каждое состояние представлено экземпляром этого класса и может быть:
Локальным — доступным только внутри одного компонента.
Глобальным — доступным из любого места приложения по ключу (key).`
          ),

          spacer("10px"),
          heading3(`# Структура MCState`),

          ulList([
            "id — уникальный идентификатор состояния.",
            "value — текущее значение состояния.",
            "traceKey — ключ состояния.",
            "virtualCollection — коллекция виртуальных элементов (виртуальных DOM-узлов), связанных с этим состоянием.",
            "fcCollection — набор функциональных контейнеров (Function Containers), которые зависят от состояния.",
            "effectCollection — список эффектов, которые должны выполниться при его изменении.",
            "passport — разрешение на изменение состояния, выдаваемое движком MCEngine при регистрации.",
            "local — ссылка на компонент, если состояние локальное.",
            "_version и _identityHash — внутренние поля оптимизации, ускоряющие сравнение значений и предотвращающие ненужные ререндеры.",
          ]),

          spacer("10px"),

          textMuted(`Перед установкой нового значения MCState выполняет несколько уровней проверки: от быстрой (shallow) до полного глубокого сравнения. 
Это гарантирует, что интерфейс обновится только при реальных изменениях данных, а не при простом пересоздании объектов или ссылок.`),

          spacer("10px"),

          textP(`<strong> - Основные методы</strong>`),

          ulList([
            "set(newValue) — устанавливает новое значение, если оно действительно изменилось.",
            "get() — возвращает глубокую копию текущего значения, предотвращая прямые мутации.",
            "initial() — выполняет принудительную инициализацию без изменения состояния.",
            "computeShallowIdentity(value) — создаёт «подпись» значения для быстрой проверки изменений.",
            "deepEqual(a, b) — рекурсивное сравнение любых структур данных.",
            "deepClone(value) — глубокое копирование, включая циклические ссылки, массивы, карты и множества.",
          ]),
          spacer("10px"),
          textP(
            "<strong>Обратите внимание, если вы не уверены что делаете используйте только get и set для конфигурации состояния. Этого хватит в 99.9% случаев.</strong>"
          ),
          spacer("10px"),
          textP(`Продвинутые пользователи могут напрямую влиять на алгоритм сравнения состояния, модифицируя поведение <strong>computeShallowIdentity()</strong> или реализуя собственный механизм вычисления «подписи» состояния.  
Кроме того, возможен прямой доступ к внутреннему паспорту состояния через <strong>passport.value</strong>, что позволяет вручную переназначать данные, обходя стандартные проверки.`),
          spacer("10px"),
          textP(`<strong>Однако делать это строго не рекомендуется.</strong>  
Внутренний механизм MCState уже включает множество уровней оптимизации и безопасных проверок.  
Ручное вмешательство может привести к рассинхронизации контейнеров, потере связей в virtualCollection и нарушению реактивности.  
Если требуется особое поведение — лучше реализовать собственный слой поверх стандартных API MC.`)
        ),

        heading2("# Функциональные контейнеры: Углублённое исследование"),

        textP(
          `Важно понимать: приложение можно реализовать целиком на классовых компонентах, целиком на функциональных контейнерах, либо комбинировать оба подхода.`
        ),

        spacer("10px"),

        textP(
          `Чтобы не перегружать читателя сейчас, мы сфокусируемся на функциональных контейнерах — разберём их глубже: как они подписываются на состояние, как управляют эффектами, как оптимизируются и как взаимодействуют с движком рендера. 
  В отдельных разделах будет показано, как те же концепции применимы и для классовых компонентов или в гибридных архитектурах.`
        ),

        spacer("10px"),

        textP(`В этом подразделе мы пройдём следующие ключевые темы:`),

        spacer("10px"),

        ulList([
          "Жизненный цикл функционального контейнера: инициализация, подписки, очистка.",
          "Оптимизации: когда контейнеры пересчитываются и как избежать лишних ререндеров.",
          "Паттерны организации кода: композиция, мемоизация и разделение ответственности.",
        ]),

        spacer(),

        heading3('## Жизненный цикл функционального контейнера'),

      )
    );
  }
}

MCState;
