const ContainersBlock = () => {
    return $('<div>').addClass('doc_content_wrapper').append(
        title('Функциональные контейнеры: Начало работы'),
        text('В данной документации было решено начать с контейнеров функций. Они предоставляют широкий спектр возможностей для изменения подхода к построению вашего приложения и обеспечивают легкий и доступный опыт программирования на Micro Component. Для начала рассмотрим, что представляют собой контейнеры. Простейший способ показать их структуру — это начать без дополнительных абстракций, на что мы и посмотрим сейчас.'),
        
codeBlock(`$(() => {
    return $("&lt;div&gt;").text('Я Функциональный компонент!');
});`),

        text('Забегая вперёд, в такой реализации контейнеры функций могут показаться нам не такими интересными. Однако обратите внимание на переопределение функции "$" в jQuery. Теперь она принимает обратный вызов (callback), который должен вернуть нам привычный код. На самом деле, уже на этом этапе на нашей странице был создан виртуальный элемент. Мы подробно рассмотрим виртуализацию далее, но сейчас важно понять, что элемент был создан существенно иначе. Эта информация пригодится нам впоследствии. Давайте пока рассмотрим, как мы можем контролировать этот созданный элемент.'),
codeBlock(`// Micro Component
const myState = MC.createState('Привет, я создан!');

setTimeout(() => {
    myState.set('Меня изменили!');
}, 1000);

$((state) => {
    // state = ['Привет, я создан!']
    return $("&lt;div&gt;").text(state);
}, [myState]);
`),
        text('Мы объявили контейнер, в котором предоставляем элемент div с текстом, равным значению state. В state всегда будет содержаться массив переданных в него сущностей. Сама сущность, которая создается, называется "Контроллер". Эта абстракция обеспечивает удобную работу с перерисовкой элементов в контейнерах, к которым они привязаны.'),
  
        alertBlock(
            $('<span>').addClass('doc_text').text('Не рекомендуется использовать "Контроллеры" как обычные контейнеры для передачи данных. Несмотря на то, что они могут работать нормально, внутри себя они попытаются использовать свои возможности для изменения веб-страницы.')
        ),

        text('В данном случае мы подключили контроллер к контейнеру с использованием "[myState]". Также мы добавили setTimeout(...), который вызовет метод .set() контроллера и определит в нем новое значение. Как только произойдет вызов .set(), мы сразу изменим наш элемент соответственно с новым текстом, определенным внутри setTimeout. Прежде чем двигаться дальше, важно обсудить подход к мутированию DOM, который мы увидели. Зачем нам строить такие абстракции, если мы можем задать селектору атрибут и попытаться получить доступ к нему, например, по классу. О применяемом подходе:'),
        text('Во-первых, чем больше наша веб-страница, тем сложнее в поддержке такая структура. Те, кто уже некоторое время занимается веб-разработкой и не использует веб-фреймворки, должны быть знакомы с чувством, когда нельзя просто удалить CSS-класс из проекта, потому что по нему могут искаться какие-то селекторы, а сами селекторы могут содержать идентификаторы и атрибуты разной степени надежности.'),
        
        $('<span>').addClass('doc_text').text('Вторая причина, это отделение отображения от логики. Давайте сравним на прошлом примере:'),
        
        codeBlock(`// Без использования Micro Component
setTimeout(() => {
    $('#element').text('Меня изменили!');
    $('#element-child').text('Меня изменили!');
}, 1000);

$("&lt;div&gt;").attr('id': 'element').text('Привет, я создан!').append(
    $("&lt;span&gt;").attr('id': 'element-child').text('Я тоже!')
);

// Micro Component
const myState = MC.createState({ parent: 'Привет, я создан!', child: 'Я тоже!'});

setTimeout(() => {
    myState.set({ parent: 'Меня изменили!', child: 'Я тоже изменился.'})
}, 1000);

$((state) => {
    const [ el ] = state;
    return $("&lt;div&gt;").text(el.parent).append(
        $("&lt;span&gt;").text(el.child)
    );
}, [myState]);`),

        text('В примере, где мы не используем Micro Component, видно, как внутрь setTimeout попала часть кода, ответственная за отображение на веб-странице. С течением времени, когда веб-страница станет больше, мы будем вынуждены еще больше расширять код, отвечающий за логику. В конечном итоге придется тщательно искать места и условия, при которых происходят мутации наших элементов. В примере ниже, где мы используем Micro Component, мы видим легко читаемую структуру, которая сразу показывает, как происходит изменение. Там, где выполняется код логики, присутствует контроллер, который явно сигнализирует о том, что нужно мутировать привязанные к нему элементы. Таким образом, мы минимизируем присутствие отображения в функциях, отвечающих, например, за подготовку данных. Но это не все причины...'),

        subTitle('Оптимизация:'),
        text('Оптимизация — всегда сложная тема. Сейчас мы сосредоточимся на тезисе, который наилучшим образом соответствует теме рассматриваемого инструмента.'),
        
        infoBlock(
            text('При обработке информации манипулирование данными напрямую более эффективно, чем взаимодействие с объектной моделью документа (DOM), поскольку операции с данными часто связаны с оптимизированными вычислениями и итерациями, в то время как взаимодействие с DOM может повлечь за собой дополнительные накладные расходы, связанные с рендерингом и компоновкой браузера. Использование подходов, ориентированных на мутации данных, повышает производительность и скорость отклика при веб-разработке, особенно при работе со сложными наборами данных или динамическим обновлением контента.')
        ),

        text('Большинство современных инструментов стремится минимизировать обращения к DOM для повышения производительности своих веб-приложений. Давайте более подробно рассмотрим наш пример с этой точки зрения и выясним, какую именно оптимизацию мы здесь рассматриваем:'),
        
codeBlock(`// Чтобы было более наглядно, обращения к DOM выглядит следующим образом = {DOM}

// Без использования Micro Component
setTimeout(() => {
    // {DOM} (получили элемент); {DOM} (изменили элемент)
    $('#element').text('Меня изменили!');
    // {DOM} (получили элемент); {DOM} (изменили элемент)
    $('#element-child').text('Меня изменили!');
}, 1000);
$("&lt;div&gt;").attr('id': 'element').text('Привет, я создан!').append(
    $("&lt;span&gt;").attr('id': 'element-child').text('Я тоже!')
);

// Micro Component
const myState = MC.createState({ parent: 'Привет, я создан!', child: 'Я тоже!'});

setTimeout(() => {
    // {DOM} (изменили элемент)
    myState.set({ parent: 'Меня изменили!', child: 'Я тоже изменился.'})
}, 1000);

$((state) => {
    const [ el ] = state;
    return $("&lt;div&gt;").text(el.parent).append(
        $("&lt;span&gt;").text(el.child)
    );
}, [myState]);`),

        text('В этом примере мы не учитывали создание элементов, с точки зрения оптимизации оно одинаковое. В данном случае более интересным аспектом является изменение элементов. В варианте с использованием Micro Component мы обратились к DOM всего один раз, в то время как вариант без него включает в себя порядок больше обращений. Стоит отметить, что мы изменили всего 2 элемента, но на реальных проектах разница может быть более ощутимой.'),

        title('Контекст обработки'),

        text('Итак, давайте продолжим обсуждение оптимизации и рассмотрим дополнительные способы сделать нашу страницу более отзывчивой для действий пользователя, учитывая принципы обработки элементов в Micro Component.'),
        text('Когда вы впервые создаете элемент в компоненте Micro Component, она генерирует специальный объект "virtual" и записывает его в определенную область памяти, называемую "virtualCollection". Когда вы привязываете контроллер к элементу, он получает разрешение на изменение этого элемента, а также его ключ.'),
        text('При запросе контроллера на обновление, он обращается к Micro Component за изменениями и предоставляет ранее отданные ему ключи. Именно по этим ключам мы и находим нужные нам virtual элементы в коллекции.'),
        text('Узким моментом является количество элементов, которые могут храниться в virtualCollection. Без проблем можно управлять 500-800 элементами, и это уже довольно большое количество. Однако, как показывает практика, на глаз разницы между этими количествами вы можете не заметить. Но что если у вас 6000-20000 элементов?'),
        text('В целом на практике, создать страницу даже с 200 элементами может быть достаточно трудно, потому что они хранятся блочно, и дети элемента считаются за 1. Лучшим подходом будет разбивать наш virtualCollection на группы и искать их в конкретных местах. Давайте посмотрим, как это можно сделать:'),
codeBlock(`// Micro Component
const context = MC.createContext();
const myState = MC.createState('Привет, я создан!');

setTimeout(() => {
    myState.set('Меня изменили!');
}, 1000);

$((state) => {
    // state = ['Привет, я создан!']
    return $("&lt;div&gt;").text(state);
}, [myState], context);
`),
        text('Мы только что создали контекст и прикрепили его к контейнеру. В целом, внешние оптимизации тут закончились. Это действительно всё, что нужно от программиста на этом этапе, чтобы ускорить обработку данных. Вы можете разбить каждый свой модуль веб-страницы на определенный контекст, чтобы обозначить, в каких местах нужно искать конкретный virtual. Соответственно, контроллер сразу отдаст ключ необходимому контексту для обращения к конкретно его virtualCollection.'),
codeBlock(`const context = MC.createContext();
const context2 = MC.createContext();
// контроллёру не обязательно быть привязанным к одному контексту, 
// он скорее нужен контейнерам которые генерируют virtual

const myState = MC.createState('Привет, я создан!');

setTimeout(() => {
    // Изменени произойдут в обоих контейнерах
    myState.set('Меня изменили!');
}, 1000);

$((state) => {
    // state = ['Привет, я создан!']
    return $("&lt;div&gt;").text(state);
}, [myState], context);

$((state) => {
    // state = ['Привет, я создан!']
    return $("&lt;div&gt;").text(state);
}, [myState], context2);
`),

        text('Помните о том, что привязка множества контейнеров к контроллеру обязует их обновление. Подумайте, где вам нужна информация от контроллера. Возможно, будет лучше разделить большой контроллер на несколько и привязать их к своим контейнерам. Таким образом, вы обеспечите перерисовку страницы в нужных местах. Если вы планируете большой контейнер, вам, возможно, подойдет "Классовый компонент", о котором мы будем говорить по ходу исследования данной документации.'),
        title('Функциональные контейнеры: Погружение'),

        text('Теперь, когда мы знакомы с принципами создания и управления контейнерами, давайте более подробно обсудим их возможности, способы применения и ограничения.'),
        text('Но перед этим хочется отметить, что Micro Component вполне позволяет организовывать свободную архитектуру построения вашего проекта. Это связано с тем, что она включает в себя обязанности по легкой поддержке уже построенных ранее проектов.'),
        subTitle('Адаптивная композиция компонентов'),
        
        text('Давайте тут сразу начнём с кода:'),
codeBlock(`const store = MC.createContext();
// давайте представим, что нам нужно отобразить клиента магазина
const persons = MC.createState([]);

const view = MC.createState(true);

function loadPersons() {
    $.ajax('example_url').done((data) => {
        // data === [{
        //   name: string,
        //   secondName: string,
        //   phone: number,
        //   client: boolean,
        //   balance: number
        // }];
        
        // Тут могут быть необходимые манипуляции с данными, и их проверкой
        person.set(data);
    });
};
$('#wrapper').append(
    $((state)=> {
        const [ persons, view ] = state;

        if(!view || !persons.length) {
            return null;
        }
    
        return $('&lt;div&gt;').append(
            persons.map(item => {
                if(!item.client) {
                    return $('&lt;span&gt;').text(item.name + ' ' + item.secondName + ' ' + 'пока не является клиентом!');
                }
                $('&lt;div&gt;').append(
                    $('&lt;span&gt;').text('Имя ' + item.name),
                    $('&lt;span&gt;').text('Фамилия ' + item.secondName),
                    $('&lt;div&gt;').append(
                        $('&lt;p&gt;').text('Связь: ')
                        $('&lt;ul&gt;').append(
                            item.phones.map(phone => {
                                return $('&lt;li&gt;').append(phone)
                            })
                        )
                    ),
                    $('&lt;span&gt;').text('Текущий баланс: ' + item.balance)
                )
            });          
        );
    }, [persons, view], store),

    $('&lt;button&gt;').text('Обновить').on('click', () => {
        loadPersons();
    }),

    $('&lt;button&gt;').text('Показать/Скрыть').on('click', () => {
        view.set(!view.get());
    })
);`),

        text('Тут специально подобран более комплексный пример, сделано это ради того, чтобы вы могли сами посмотреть, как мы можем теперь организовать работу с данными и их отображением. Более важно просмотреть, что контейнер может возвращать разный набор данных в зависимости от самих данных.'),
        text('В этом примере, мы в нашем воображаемом магазине получаем список клиентов, предоставленный инженерами бэкенда. Каждый раз, когда мы нажимаем кнопку "Обновить" после запроса, наш элемент будет содержать те данные, которые пришли с сервера и попали в set(), независимо от того, что было там ранее.'),
        text('Также стоит обратить внимание на манипуляции в кнопке "Показать/Скрыть". Там мы получаем текущее значение view с помощью метода get() и, сразу заменив его на противоположное, записываем в set(). Таким образом, мы создали достаточно нагруженную логику по отображению и обновлению части нашей веб-страницы, но сделали это довольно явным и легко поддерживаемым образом.'),
        
        alertBlock(
            text('Обратите внимание, что мы всегда отдаем один селектор, в который, допустим, мы помещаем его дочерние элементы. Дело в том, что Micro Component нужна опора для создания virtual. Поэтому у нас не получится вернуть элементы, например, в массиве.'),
        ),

        text("Тем, кто поддерживает существующие проекты, надеюсь, будет приятно увидеть легкую интеграцию нашего созданного компонента в $('#wrapper'). Да, это было очевидно, ведь функция создания компонента соответствует стандартному формату jQuery, но мы впервые с этим столкнулись в данной документации."),
    
        subTitle('Динамические структуры'),

        text('В разных вариантах построения нашего ресурса, нам вполне может понадобиться логика отображения, которая сложнее, чем просто динамический элемент, тут нам будет полезно знать - как построить структуры. В понимании они не сложнее обычного динамического контейнера, но есть моменты, которые нужно учитывать при построении динамических структур:'),

codeBlock(`const context = MC.createContext();

const mainState = MC.createState({
    text: "Я основной элемент",
    cssClass: 'main__element'
});

const childState = MC.createState({
    text: "Я дочерний элемент",
    cssClass: 'child__element'
});

// Обычное создание динамического контейнера
$((state) => {
    const [ main ] = state; 
    return $('&lt;div&gt;').text(main.text).addClass(main.cssClass).append(
        // Добавление дочернего динамического контейнера
        $((state) => {
            const [ child ] = state;
            return $('&lt;div&gt;').text(child.text).addClass(child.cssClass)
        }, [childState], context)
    )
}, [mainState], context)`),
        
        text('Тут есть важные уточнения:'),
        alertBlock(
            text('Использование контроллера родительского контейнера в качестве дочерней зависимости приведет к неоптимизированному обновлению DOM, пожалуйста, избегайте такой реализации.')
        ),
        text('Это означает, что если мы используем mainState в качестве зависимости в дочернем компоненте, мы совершим 3 обновления. Чтобы понять, почему так произойдет, нужно разобраться, как будет организовано обновление в обычной ситуации.'),
        
        text('При обновлении mainState мы потребуем обновить все его дочерние контейнеры. При обновлении childState мы обновим только привязанный к нему контейнер; дочерний контейнер не будет пытаться обновить родительский.'),

        text('Соответственно, если мы поместим mainState в дочерний контейнер как зависимость, первой итерацией будет обновление своего и дочернего контейнера, а затем только дочернего.'),

        text('Исходя из этого, у внимательного читателя может возникнуть вопрос: "Как мне извлечь данные из родительского контроллера в дочернем элементе?" Логично было бы предположить, что это возможно просто передачей реквизита из родителя.'),
codeBlock(`$((state) => {
    const [ main ] = state; 
    return $('&lt;div&gt;').text(main.text).addClass(main.cssClass).append(
        $((state) => {
            const [ child ] = state;
            // Это неверный подход
            return $('&lt;div&gt;').text(child.text).addClass(child.cssClass).append('&lt;div&gt;').text('Мой родитель говорит ' + main.text)
        }, [childState], context)
    )
}, [mainState], context)`),

        text('Мы действительно получим на вход данные, но проблема в том, что не сможем их актуализировать. Контейнер, хоть и дочерний, достаточно самостоятельный, чтобы определить свой приходящий реквизит. Поэтому он сохранит значение этой переменной у себя в памяти один раз и будет использовать его при собственном обновлении, независимо от того, кто его обновил - родитель или зависимость.'),
        text('Таким образом, если вам нужно использовать данные родителя в дочернем контейнере и обновлять их в соответствии с изменениями в родительском контроллере, рекомендуется явно запрашивать актуальную информацию у родителя и передавать ее в дочерний контейнер.'),
codeBlock(`$((state) => {
    const [ main ] = state; 
    return $('&lt;div&gt;').text(main.text).addClass(main.cssClass).append(
        $((state) => {
            const [ child ] = state;
            // Так мы будем знать актуальное значение, при любой операции обновления
            const main = mainState.get();
            return $('&lt;div&gt;').text(child.text).addClass(child.cssClass).append('&lt;div&gt;').text('Мой родитель говорит ' + main.text)
        }, [childState], context)
    )
}, [mainState], context)`),

        infoBlock(text("Важной особенностью использования .get() является то, что эта функция не инициирует обновление контейнеров. Вместо этого она просто предоставляет текущие данные, которые уже содержатся в контроллере.")),

        title('Модулирование'),

        text('При создании ресурса может возникнуть необходимость повторного использования контейнера в другом месте. При обсуждении подходов к созданию модулей предпочтительнее использование компонентов ( в разделе "Компоненты" ). Мы также можем вынести логику поведения в отдельные модули в функциональных контейнерах, но это не будет лучшим решением, так как перекрытие элементов может негативно сказаться на читаемости. Предположим:'),
        codeBlock(
`const context = MC.createContext();

const btnOne = MC.createState({
    text: 'Кнопка один',
    action: () => alert('Я кнопка один!'),
    class: 'one_btn'
});

const btnTwo = MC.createState({
    text: 'Кнопка два',
    action: () => alert('Я кнопка два!'),
    class: 'two_btn'
});

const Button = (state) => {
    const [ button ] = state;
    return $('&lt;button&gt;').addClass(button.class).on('click', button.action);
};

// Это не будет работать
$(Button, [btnOne], context);
$(Button, [btnTwo], context);`),

    text('Такая реализация очень удобна для создания описательного кода. Однако, при создании элемента он будет ссылаться на первый компонент, следовательно, мы не получим обновлений для последующих. Чтобы избежать такого поведения, вы можете определить другую область хранения и исключить их перекрытие - тогда всё будет работать.'),

codeBlock(
`const context = MC.createContext();
const context2 = MC.createContext();

const btnOne = MC.createState({
    text: 'Кнопка один',
    action: () => alert('Я кнопка один!'),
    class: 'one_btn'
});

const btnTwo = MC.createState({
    text: 'Кнопка два',
    action: () => alert('Я кнопка два!'),
    class: 'two_btn'
});

const btnThree = MC.createState({
    text: 'Кнопка три',
    action: () => alert('Я кнопка три!'),
    class: 'three_btn'
});

const Button = (state) => {
    const [ button ] = state;
    return $('&lt;button&gt;').addClass(button.class).on('click', button.action);
};

// Мы определили их в разных контекстах и теперь всё будет работать.
$(Button, [btnOne], context);
$(Button, [btnTwo], context2);
$(Button, [btnThree]);
`),
        text('Обратите внимание, что мы определили одну из кнопок в анонимном контексте. Вид контекста в данном случае не имеет решающей роли, главное, чтобы у них была разная область хранения.'),
        
        alertBlock(
            text('Настоятельно НЕ рекомендуется использовать такой подход в формате функциональных контейнеров! С расширением вашего проекта вам будет гораздо тяжелее следить за переданным контекстом!')
        ),

        text('Также к минусам такого подхода мы можем отметить невозможность передать данные, которые должны быть получены кроме данных в контроллере. А вот где всё построено на такой реализации, но с возможностью удобной и правильной работы - вы можете изучить в следующем разделе!'),
    );
}