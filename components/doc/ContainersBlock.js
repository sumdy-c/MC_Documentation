const ContainersBlock = () => {
    return $('<div>').addClass('doc_content_wrapper').append(
        title('Функциональные контейнеры: Начало работы'),
        text('В данной документации, было решено начать именно с контейнеров функций. Они предоставляют широкий спектор возможностей для реализации изменения подхода в построении вашего приложения, и обеспечивают самый легкий и доступный опыт кодирования на Micro Component.'),
        text('Начиная разбирать что из себя представляют конейнеры, для начала проще всего показать как они выглядят без дополнительных абстракций, на что сейчас мы и посмотрим:'),
        
codeBlock(`$(() => {
    return $("&lt;div&gt;").text('Я Функциональный компонент!');
});`),

        text('Забегая вперёд в такой реализации они нам мало будут интересны, но без обратите внимание на переопределение функции "$" в jQuery. Теперь она принимает callback который должен будет вернуть всем нам привычный код.'),
        
        
        text('На самом деле уже на этом этапе на нашей странице был создан виртуальный элемент. Мы обязательно подробнее рассмотрим виртуализацию дальше, но сейчас нужно понять что элемент был создан сильно иначе. Это информация нам понадобиться далее, давайте пока рассмотрим как мы можем контролировать данный элемент.'),
codeBlock(`// Micro Component
const myState = MC.createState('Привет, я создан!');

setTimeout(() => {
    myState.set('Меня изменили!');
}, 1000);

$((state) => {
    // state = ['Привет, я создан!']
    return $("&lt;div&gt;").text(state);
}, [myState]);
`),
        text('Давайте рассмотрим эту структуру подробнее:'),
        text('Мы объявили контейнер, в котором мы отдаем элемент div c текстом, который равен state. В state нам всегда будет приходить массив переданных в него сущностей. Сама сущность которая создаётся называется "Контроллёр". Это абстракция которая обеспечивает удобную работу с перерисовкой элементов в контейнерах к которым они привязаны.'),
        
        alertBlock(
            $('<span>').addClass('doc_text').text('Не используйте "Контроллёров" как обычные контейнеры для передачи данных. Не смотря на то что он сработает нормально, внутри себя он попытается использовать свое право на изменение веб-страницы.')
        ),

        text('В данном случае мы подключили его к контейнеру с помощью "[myState]".'),
        text('Также мы добавили setTimeout(...) который вызовет метод .set() контроллёра и определит в нём новое значение.'),
        text('Как только прошёл вызов .set() мы сразу изменим наш элемент. Соответственно, с уже новым текстом который мы определили в .set(), внутри setTimeout.'),
        text('Прежде чем мы двинемся дальше, нужно обсудить важный момент, который касается подхода к мутированию DOM который мы увидели. Зачем нам строить такие абстрации, если мы можем задать селектору атрибут и пытаться получить доступ по нему или допустим по классу, а в дальнейшим изменить его.'),
        text('О применяемом подходе:'),
        $('<span>').addClass('doc_text').text('Во-первых, из очевидного, чем больше наша веб-страница, тем тяжелее в поддержке такая структура. Тем кто какое-то время уже занимается веб-разработкой и кто не использует веб-фреймворки должно быть уже знакомо чувство, когда нельзя просто удалить css класс из проекта потому что по нему могут искаться какие-то селекторы, а сами селекторы изобилуют id и атрибутами разной степени надёжности.'),
        $('<span>').addClass('doc_text').text('Вторая причина, это отделение отображения от логики. Давайте сравним на прошлом примере:'),
        
        codeBlock(`// Без использования Micro Component
setTimeout(() => {
    $('#element').text('Меня изменили!');
    $('#element-child').text('Меня изменили!');
}, 1000);

$("&lt;div&gt;").attr('id': 'element').text('Привет, я создан!').append(
    $("&lt;span&gt;").attr('id': 'element-child').text('Я тоже!')
);

// Micro Component
const myState = MC.createState({ parent: 'Привет, я создан!', child: 'Я тоже!'});

setTimeout(() => {
    myState.set({ parent: 'Меня изменили!', child: 'Я тоже изменился.'})
}, 1000);

$((state) => {
    const [ el ] = state;
    return $("&lt;div&gt;").text(el.parent).append(
        $("&lt;span&gt;").text(el.child)
    );
}, [myState]);`),
        text('В примере где мы не используем Micro Component, мы видим как в наш setTimeout попала часть кода, которая явно отвечает за отображение на нашей веб-странице. В последствии когда наша веб страница будет явно больше чем в примере, мы будем вынуждены еще больше расширять наш код который отвечает за логику, в конечном счете нам придётся долго искать в каком месте и при каких условиях происходит мутация наших элементов.'),
        text('В свою очередь в примере ниже, мы обнаруживаем вполне легко читаемую структуру, которая сразу говорит нам как происходит изменение, а там где выполняется код логики присутствует лишь контроллер который явно сигнализирует о том, что нужно мутировать привязанные к нему элементы. Поэтому мы минимизируем присутствие отображения в наших функциях отвечающие допустим за подготовку данных.'),
        text('Но это не все причины, последняя самая важная.'),
        subTitle('Оптимизация:'),
        text('Оптимизация, это всегда сложная тема. Сейчас мы сконцентрируемся на тезисе, который ближе всего к теме рассматриваемого инструмента'),
        
        infoBlock(
            text('При обработке информации манипулирование данными напрямую более эффективно, чем взаимодействие с объектной моделью документа (DOM), поскольку операции с данными часто связаны с оптимизированными вычислениями и итерациями, в то время как взаимодействие с DOM может повлечь за собой дополнительные накладные расходы, связанные с рендерингом и компоновкой браузера. Использование подходов, ориентированных на мутации данных, повышает производительность и скорость отклика при веб-разработке, особенно при работе со сложными наборами данных или динамическим обновлением контента.')
        ),

        text('Поэтому большинство современных инструментов старается минимизировать обращения к DOM, чтобы повысить производительность своих веб приложений, но лучше более подробно рассмотрим наш пример с этой стороны и поймём о какой оптимизации тут стоит говорить:'),
        
codeBlock(`// Чтобы было более наглядно, обращения к DOM выглядит следующим образом = {DOM}

// Без использования Micro Component
setTimeout(() => {
    // {DOM} (получили элемент); {DOM} (изменили элемент)
    $('#element').text('Меня изменили!');
    // {DOM} (получили элемент); {DOM} (изменили элемент)
    $('#element-child').text('Меня изменили!');
}, 1000);
$("&lt;div&gt;").attr('id': 'element').text('Привет, я создан!').append(
    $("&lt;span&gt;").attr('id': 'element-child').text('Я тоже!')
);

// Micro Component
const myState = MC.createState({ parent: 'Привет, я создан!', child: 'Я тоже!'});

setTimeout(() => {
    // {DOM} (изменили элемент)
    myState.set({ parent: 'Меня изменили!', child: 'Я тоже изменился.'})
}, 1000);

$((state) => {
    const [ el ] = state;
    return $("&lt;div&gt;").text(el.parent).append(
        $("&lt;span&gt;").text(el.child)
    );
}, [myState]);`),

        text('Мы не учитывали создание элементов, со стороны оптимизации в этом примере оно одинаковое, в данном случае более интересно их изменение. В варианте где у нас использован Micro Component мы обратились к DOM один раз, а без него на порядок больше. Стоит отметить, что мы изменили 2 элемента, на реальных проектах разница будет более ощутимой.'),

        title('Контекст обработки'),
        text('Если мы уже начали обсуждать оптимизацию, стоит развить эту тему и посмотреть какие еще есть способы сделать нашу страницу более отзывчивой для действий пользователя, для этого стоит понимать приницпы при обработке элементов в Micro Component'),
        text('Когда вы впервые создаете элемент в компоненте Micro Component генерирует специальный объект "virtual" и записывает его в определённую область памяти, "virtualCollection". Когда вы привязываете к элементу контроллера, он получает разрешение на изменение этого элемента, и его ключ.'),
        text('Когда мы просим контроллёра об обновлении, он обращается за изменениями к Micro Component и предоставляет отданные ему ранее ключи - по этим ключам мы и находим нужные нам virtual.'),
        text('Узкий момент, это количество элементов, которые могут храниться в virtualCollection. Без проблем перебрать 500-800 элементов, хоть это уже приличное количество, как показывает практика, на глаз разницы вы не заметите, но если их 6000-20000 ?'),
        text('На практике, даже 200 элементов сделать достаточно тяжело, потому что они хранятся блочно, и дети элемента считаются за 1, но лучшим подходом будет разбивать наш virtualCollection на группы и искать их в конкретных местах, давайте посмотрим как этого можно добиться:'),
codeBlock(`// Micro Component
const context = MC.createContext();
const myState = MC.createState('Привет, я создан!');

setTimeout(() => {
    myState.set('Меня изменили!');
}, 1000);

$((state) => {
    // state = ['Привет, я создан!']
    return $("&lt;div&gt;").text(state);
}, [myState], context);
`),
        text('Мы только что создали контекст и прикрепили его к контейнеру. В целом, внешние оптимизации тут закончились, это действительно всё то что нужно от программиста на этом этапе чтобы ускорить обработку данных.'),
        text('Вы можете разбить каждый свой модуль веб страницы на определённый контекст, чтобы обозначить в каких местах нужно искать конкретный virtual, соответвенно контроллёр сразу отдаст ключ необходимому контексту для обращению к конкретно его virtualCollection.'),

codeBlock(`const context = MC.createContext();
const context2 = MC.createContext();
// контроллёру не обязательно быть привязанным к одному контексту, 
// он скорее нужен контейнерам которые генерируют virtual

const myState = MC.createState('Привет, я создан!');

setTimeout(() => {
    // Изменени произойдут в обоих контейнерах
    myState.set('Меня изменили!');
}, 1000);

$((state) => {
    // state = ['Привет, я создан!']
    return $("&lt;div&gt;").text(state);
}, [myState], context);

$((state) => {
    // state = ['Привет, я создан!']
    return $("&lt;div&gt;").text(state);
}, [myState], context2);
`),

        text('Помните о том, что привязка многочиленных контейнеров к контроллёру обязует их обновление, подумайте где вам нужна информация от контроллёра, возможно будет лучше разделить большой контроллёр на несколько и привязать их к своим контейнерам, тем самым обеспечив перерисовку страницы в нужных местах, так же если вы планируете большой контейнер, вам скорее подойдет "Классовый компонент", о котором мы будем говорить по ходу исследования данной документации.'),
    );
}