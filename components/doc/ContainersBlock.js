const ContainersBlock = () => {
    return $('<div>').addClass('doc_content_wrapper').append(
        title('Функциональные контейнеры: Начало работы'),
        text('В данной документации, было решено начать именно с контейнеров функций. Они предоставляют широкий спектор возможностей для реализации изменения подхода в построении вашего приложения, и обеспечивают самый легкий и доступный опыт кодирования на Micro Component.'),
        text('Начиная разбирать что из себя представляют конейнеры, для начала проще всего показать как они выглядят без дополнительных абстракций, на что сейчас мы и посмотрим:'),
        
codeBlock(`$(() => {
    return $("&lt;div&gt;").text('Я Функциональный компонент!');
});`),

        text('Забегая вперёд в такой реализации они нам мало будут интересны, но без обратите внимание на переопределение функции "$" в jQuery. Теперь она принимает callback который должен будет вернуть всем нам привычный код.'),
        
        
        text('На самом деле уже на этом этапе на нашей странице был создан виртуальный элемент. Мы обязательно подробнее рассмотрим виртуализацию дальше, но сейчас нужно понять что элемент был создан сильно иначе. Это информация нам понадобиться далее, давайте пока рассмотрим как мы можем контролировать данный элемент.'),
codeBlock(`// Micro Component
const myState = MC.createState('Привет, я создан!');

setTimeout(() => {
    myState.set('Меня изменили!');
}, 1000);

$((state) => {
    // state = ['Привет, я создан!']
    return $("&lt;div&gt;").text(state);
}, [myState]);
`),
        text('Давайте рассмотрим эту структуру подробнее:'),
        text('Мы объявили контейнер, в котором мы отдаем элемент div c текстом, который равен state. В state нам всегда будет приходить массив переданных в него сущностей. Сама сущность которая создаётся называется "Контроллёр". Это абстракция которая обеспечивает удобную работу с перерисовкой элементов в контейнерах к которым они привязаны.'),
        
        alertBlock(
            $('<span>').addClass('doc_text').text('Не используйте "Контроллёров" как обычные контейнеры для передачи данных. Не смотря на то что он сработает нормально, внутри себя он попытается использовать свое право на изменение веб-страницы.')
        ),

        text('В данном случае мы подключили его к контейнеру с помощью "[myState]".'),
        text('Также мы добавили setTimeout(...) который вызовет метод .set() контроллёра и определит в нём новое значение.'),
        text('Как только прошёл вызов .set() мы сразу изменим наш элемент. Соответственно, с уже новым текстом который мы определили в .set(), внутри setTimeout.'),
        text('Прежде чем мы двинемся дальше, нужно обсудить важный момент, который касается подхода к мутированию DOM который мы увидели. Зачем нам строить такие абстрации, если мы можем задать селектору атрибут и пытаться получить доступ по нему или допустим по классу, а в дальнейшим изменить его.'),
        text('О применяемом подходе:'),
        $('<span>').addClass('doc_text').text('Во-первых, из очевидного, чем больше наша веб-страница, тем тяжелее в поддержке такая структура. Тем кто какое-то время уже занимается веб-разработкой и кто не использует веб-фреймворки должно быть уже знакомо чувство, когда нельзя просто удалить css класс из проекта потому что по нему могут искаться какие-то селекторы, а сами селекторы изобилуют id и атрибутами разной степени надёжности.'),
        $('<span>').addClass('doc_text').text('Вторая причина, это отделение отображения от логики. Давайте сравним на прошлом примере:'),
        
        codeBlock(`// Без использования Micro Component
setTimeout(() => {
    $('#element').text('Меня изменили!');
    $('#element-child').text('Меня изменили!');
}, 1000);

$("&lt;div&gt;").attr('id': 'element').text('Привет, я создан!').append(
    $("&lt;span&gt;").attr('id': 'element-child').text('Я тоже!')
);

// Micro Component
const myState = MC.createState({ parent: 'Привет, я создан!', child: 'Я тоже!'});

setTimeout(() => {
    myState.set({ parent: 'Меня изменили!', child: 'Я тоже изменился.'})
}, 1000);

$((state) => {
    const [ el ] = state;
    return $("&lt;div&gt;").text(el.parent).append(
        $("&lt;span&gt;").text(el.child)
    );
}, [myState]);`),
        text('В примере где мы не используем Micro Component, мы видим как в наш setTimeout попала часть кода, которая явно отвечает за отображение на нашей веб-странице. В последствии когда наша веб страница будет явно больше чем в примере, мы будем вынуждены еще больше расширять наш код который отвечает за логику, в конечном счете нам придётся долго искать в каком месте и при каких условиях происходит мутация наших элементов.'),
        text('В свою очередь в примере ниже, мы обнаруживаем вполне легко читаемую структуру, которая сразу говорит нам как происходит изменение, а там где выполняется код логики присутствует лишь контроллер который явно сигнализирует о том, что нужно мутировать привязанные к нему элементы. Поэтому мы минимизируем присутствие отображения в наших функциях отвечающие допустим за подготовку данных.'),
        text('Но это не все причины, последняя самая важная.'),
        subTitle('Оптимизация:'),
        text('Оптимизация, это всегда сложная тема. Сейчас мы сконцентрируемся на тезисе, который ближе всего к теме рассматриваемого инструмента'),
        
        infoBlock(
            text('При обработке информации манипулирование данными напрямую более эффективно, чем взаимодействие с объектной моделью документа (DOM), поскольку операции с данными часто связаны с оптимизированными вычислениями и итерациями, в то время как взаимодействие с DOM может повлечь за собой дополнительные накладные расходы, связанные с рендерингом и компоновкой браузера. Использование подходов, ориентированных на мутации данных, повышает производительность и скорость отклика при веб-разработке, особенно при работе со сложными наборами данных или динамическим обновлением контента.')
        ),

        text('Поэтому большинство современных инструментов старается минимизировать обращения к DOM, чтобы повысить производительность своих веб приложений, но лучше более подробно рассмотрим наш пример с этой стороны и поймём о какой оптимизации тут стоит говорить:'),
        
codeBlock(`// Чтобы было более наглядно, обращения к DOM выглядит следующим образом = {DOM}

// Без использования Micro Component
setTimeout(() => {
    // {DOM} (получили элемент); {DOM} (изменили элемент)
    $('#element').text('Меня изменили!');
    // {DOM} (получили элемент); {DOM} (изменили элемент)
    $('#element-child').text('Меня изменили!');
}, 1000);
$("&lt;div&gt;").attr('id': 'element').text('Привет, я создан!').append(
    $("&lt;span&gt;").attr('id': 'element-child').text('Я тоже!')
);

// Micro Component
const myState = MC.createState({ parent: 'Привет, я создан!', child: 'Я тоже!'});

setTimeout(() => {
    // {DOM} (изменили элемент)
    myState.set({ parent: 'Меня изменили!', child: 'Я тоже изменился.'})
}, 1000);

$((state) => {
    const [ el ] = state;
    return $("&lt;div&gt;").text(el.parent).append(
        $("&lt;span&gt;").text(el.child)
    );
}, [myState]);`),

        text('Мы не учитывали создание элементов, со стороны оптимизации в этом примере оно одинаковое, в данном случае более интересно их изменение. В варианте где у нас использован Micro Component мы обратились к DOM один раз, а без него на порядок больше. Стоит отметить, что мы изменили 2 элемента, на реальных проектах разница будет более ощутимой.'),

        title('Контекст обработки'),
        text('Если мы уже начали обсуждать оптимизацию, стоит развить эту тему и посмотреть какие еще есть способы сделать нашу страницу более отзывчивой для действий пользователя, для этого стоит понимать приницпы при обработке элементов в Micro Component'),
        text('Когда вы впервые создаете элемент в компоненте Micro Component генерирует специальный объект "virtual" и записывает его в определённую область памяти, "virtualCollection". Когда вы привязываете к элементу контроллера, он получает разрешение на изменение этого элемента, и его ключ.'),
        text('Когда мы просим контроллёра об обновлении, он обращается за изменениями к Micro Component и предоставляет отданные ему ранее ключи - по этим ключам мы и находим нужные нам virtual.'),
        text('Узкий момент, это количество элементов, которые могут храниться в virtualCollection. Без проблем перебрать 500-800 элементов, хоть это уже приличное количество, как показывает практика, на глаз разницы вы не заметите, но если их 6000-20000 ?'),
        text('На практике, даже 200 элементов сделать достаточно тяжело, потому что они хранятся блочно, и дети элемента считаются за 1, но лучшим подходом будет разбивать наш virtualCollection на группы и искать их в конкретных местах, давайте посмотрим как этого можно добиться:'),
codeBlock(`// Micro Component
const context = MC.createContext();
const myState = MC.createState('Привет, я создан!');

setTimeout(() => {
    myState.set('Меня изменили!');
}, 1000);

$((state) => {
    // state = ['Привет, я создан!']
    return $("&lt;div&gt;").text(state);
}, [myState], context);
`),
        text('Мы только что создали контекст и прикрепили его к контейнеру. В целом, внешние оптимизации тут закончились, это действительно всё то что нужно от программиста на этом этапе чтобы ускорить обработку данных.'),
        text('Вы можете разбить каждый свой модуль веб страницы на определённый контекст, чтобы обозначить в каких местах нужно искать конкретный virtual, соответвенно контроллёр сразу отдаст ключ необходимому контексту для обращению к конкретно его virtualCollection.'),

codeBlock(`const context = MC.createContext();
const context2 = MC.createContext();
// контроллёру не обязательно быть привязанным к одному контексту, 
// он скорее нужен контейнерам которые генерируют virtual

const myState = MC.createState('Привет, я создан!');

setTimeout(() => {
    // Изменени произойдут в обоих контейнерах
    myState.set('Меня изменили!');
}, 1000);

$((state) => {
    // state = ['Привет, я создан!']
    return $("&lt;div&gt;").text(state);
}, [myState], context);

$((state) => {
    // state = ['Привет, я создан!']
    return $("&lt;div&gt;").text(state);
}, [myState], context2);
`),

        text('Помните о том, что привязка многочиленных контейнеров к контроллёру обязует их обновление, подумайте где вам нужна информация от контроллёра, возможно будет лучше разделить большой контроллёр на несколько и привязать их к своим контейнерам, тем самым обеспечив перерисовку страницы в нужных местах, так же если вы планируете большой контейнер, вам скорее подойдет "Классовый компонент", о котором мы будем говорить по ходу исследования данной документации.'),
        title('Функциональные контейнеры: Погружение'),
        text('Теперь когда мы знакомы с принципами создания и управления контейнерами, нужно более подробно поговорить об их возможностях, способах применения и ограничениях.'),
        text('Но перед этим хочется отметить, что Micro Component вполне позволяет организовывать свободную архитектуру построения вашего проекта, в связи с тем что она включает в себя обязанности по легкой поддержке уже построенных ранее проектов.'),
        subTitle('Адаптивная композиция компонентов'),
        text('Как правило, не смотря на приведённые ранее примеры более выгодно смотрится способность организовать на Micro Component Динамическую генерацию контента, давайте сразу рассмотрим пример:'),
codeBlock(`const store = MC.createContext();
// давайте представим, что нам нужно отобразить клиента магазина
const persons = MC.createState([]);

const view = MC.createState(true);

function loadPersons() {
    $.ajax('example_url').done((data) => {
        // data === [{
        //   name: string,
        //   secondName: string,
        //   phone: number,
        //   client: boolean,
        //   balance: number
        // }];
        
        // Тут могут быть необходимые манипуляции с данными, и их проверкой
        person.set(data);
    });
};
$('#wrapper').append(
    $((state)=> {
        const [ persons, view ] = state;

        if(!view || !persons.length) {
            return null;
        }
    
        return $('&lt;div&gt;').append(
            persons.map(item => {
                if(!item.client) {
                    return $('&lt;span&gt;').text(item.name + ' ' + item.secondName + ' ' + 'пока не является клиентом!');
                }
                $('&lt;div&gt;').append(
                    $('&lt;span&gt;').text('Имя ' + item.name),
                    $('&lt;span&gt;').text('Фамилия ' + item.secondName),
                    $('&lt;div&gt;').append(
                        $('&lt;p&gt;').text('Связь: ')
                        $('&lt;ul&gt;').append(
                            item.phones.map(phone => {
                                return $('&lt;li&gt;').append(phone)
                            })
                        )
                    ),
                    $('&lt;span&gt;').text('Текущий баланс: ' + item.balance)
                )
            });          
        );
    }, [persons, view], store),

    $('&lt;button&gt;').text('Обновить').on('click', () => {
        loadPersons();
    }),

    $('&lt;button&gt;').text('Показать/Скрыть').on('click', () => {
        view.set(!view.get());
    })
);`),

        text('Тут специально подобран более комплексный пример, сделано это ради того чтобы вы смогли сами посмотреть как мы можем теперь организовать работу с данными и их отображением.'),
        text('Но более важно просмотреть что контейнер может возвращать разный набор данных в зависимости от самих данных. В этом примере, мы в нашем воображаемом магазине, получаем список наших клиентов, которые нам предоставили инженеры бэкенда. Каждый раз когда мы будем нажимать на кнопку "Обновить", после запроса наш элемент будет содержать в себе те данные которые пришли с сервера и попали в set() независимо от того что было там ранее.'),
        text('Так же, стоит обратить внимание на манипуляции в кнопке "Показать/Скрыть", там мы получаем текущее значение view, с помощью метода get() и сразу заменив его на противоположное - записываем в set().'),
        text('Таким образом, мы создали достаточно нагруженную логику по отображению и обновлению части нашей веб страницы, но сделали это довольно явным и легко доступным в поддержке образом.'),
        
        alertBlock(
            text('Обратите внимание, что мы всегда отдаём один селектор, в который уже допустим мы помещаем его дочерние элементы. Дело в том, что Micro Component нужна опора для создания virtual. Поэтому у нас не получится вернуть элементы допустим в массиве.'),
        ),

        text("Тем, кто поддерживает существующие проекты, надеюсь будет приятно увидеть легкую интеграцию нашего созданного компонента в $('#wrapper'). Да, это было очевидно, ведь функция создания компонента соответствует стандартному формату jQuery, но мы впервые с этим столкнулись в данной документации."),
    
        subTitle('Динамические структуры'),

        text('В разных вариантах построения нашего ресурса, нам вполне может понадобиться логика отображения, куда сложнее просто динамического элемента. В понимании они не сложнее обычного динамического контейнера, но есть моменты которые нужно учитывать при построении динамических структур:'),

codeBlock(`const context = MC.createContext();

const mainState = MC.createState({
    text: "Я основной элемент",
    cssClass: 'main__element'
});

const childState = MC.createState({
    text: "Я дочерний элемент",
    cssClass: 'child__element'
});

// Обычное создание динамического контейнера
$((state) => {
    const [ main ] = state; 
    return $('&lt;div&gt;').text(main.text).addClass(main.cssClass).append(
        // Добавление дочернего динамического контейнера
        $((state) => {
            const [ child ] = state;
            return $('&lt;div&gt;').text(child.text).addClass(child.cssClass)
        }, [childState], context)
    )
}, [mainState], context)`),
        
        text('Тут есть важные уточнения:'),
        alertBlock(
            text('Использование контроллера родительского контейнера в качестве дочерней зависимости приведет к не оптимизированному обновлению DOM, пожалуйста, избегайте такой реализации.')
        ),
        text('Это означает, что если мы используем как зависимость mainState, в дочернем компоненте, мы совершим 3 обновления. Чтобы понять почему так произойдет, надо понять как будет организованно обновление в обычной ситуации.'),
        
        text('При обновлении mainState мы потребуем обновить все его дочерние контейнеры. При обновлении childState мы обновим только привязанный к нему контейнер, дочерний не будет пытаться обновить родительский.'),

        text('Соответсвенно, если мы поместим mainState в дочерний контейнер как зависимость, первой итерацией будет обновление своего и дочернего контейнера, а потом только дочернего.'),

        text('Исходя из этого у внимательного читателя может возникнуть вопрос, как мне извлечь данные из родительского контроллера в дочернем элементе, хотя логично было бы предположить что это возможно просто передачей реквизита из родителя.'),
codeBlock(`$((state) => {
    const [ main ] = state; 
    return $('&lt;div&gt;').text(main.text).addClass(main.cssClass).append(
        $((state) => {
            const [ child ] = state;
            // Это неверный подход
            return $('&lt;div&gt;').text(child.text).addClass(child.cssClass).append('&lt;div&gt;').text('Мой родитель говорит ' + main.text)
        }, [childState], context)
    )
}, [mainState], context)`),
        text('Мы действительно получим на вход данные, но проблема в том - не сможем их актуализировать. Дело в том, что контейнер хоть и дочерний, но достаточно самостоятельный чтобы определить свой приходящий реквизит. Поэтому он один раз сохранит значение этой переменной у себя в памяти, а потом будет использовать его при собственном обновлении, и не важно кто его обновил - родитель или зависимость.'),
        text('Для правильного и плавного обновления, где нам будут нужны данные родителя решением будет попросить стейт отдать актуальную информацию о себе, и далее контейнер получив её использует как обычно.'),
codeBlock(`$((state) => {
    const [ main ] = state; 
    return $('&lt;div&gt;').text(main.text).addClass(main.cssClass).append(
        $((state) => {
            const [ child ] = state;
            // Так мы будем знать актуальное значение, при любой операции обновления
            const main = mainState.get();
            return $('&lt;div&gt;').text(child.text).addClass(child.cssClass).append('&lt;div&gt;').text('Мой родитель говорит ' + main.text)
        }, [childState], context)
    )
}, [mainState], context)`),

        infoBlock(text('Важное замечание: .get() не пытается вызвать обновление контейнеров - вместо этого он просто предоставляет имеющиеся у него данные.')),

        title('Модулирование'),

        text('При создании ресурса, нам может потребоваться переиспользовать контейнер в другом месте, когда мы говорим о подходах создания модулей - куда лучше выглядит использование компонентов. Функциональных контейнерах мы тоже в состоянии вынести логику поведения в отдельные модули, но это будет не самым лучшим решением, так как в связи с перекрытием элементов может негативно сказаться на читаемости. Допустим:'),
        codeBlock(
`const context = MC.createContext();

const btnOne = MC.createState({
    text: 'Кнопка один',
    action: () => alert('Я кнопка один!'),
    class: 'one_btn'
});

const btnTwo = MC.createState({
    text: 'Кнопка два',
    action: () => alert('Я кнопка два!'),
    class: 'two_btn'
});

const Button = (state) => {
    const [ button ] = state;
    return $('&lt;button&gt;').addClass(button.class).on('click', button.action);
};

// Это не будет работать
$(Button, [btnOne], context);
$(Button, [btnTwo], context);`),

    text('Такая реализация очень удобна для создания описательного кода, но при создании элемента он будет ссылаться на первый компонент, следовательно мы не получим обновлений для последующих. Чтобы избежать такого поведения вы можете определить другую область хранения и исключить их перекрытие - тогда всё будет работать.'),

codeBlock(
`const context = MC.createContext();
const context2 = MC.createContext();

const btnOne = MC.createState({
    text: 'Кнопка один',
    action: () => alert('Я кнопка один!'),
    class: 'one_btn'
});

const btnTwo = MC.createState({
    text: 'Кнопка два',
    action: () => alert('Я кнопка два!'),
    class: 'two_btn'
});

const btnThree = MC.createState({
    text: 'Кнопка три',
    action: () => alert('Я кнопка три!'),
    class: 'three_btn'
});

const Button = (state) => {
    const [ button ] = state;
    return $('&lt;button&gt;').addClass(button.class).on('click', button.action);
};

// Мы определили их в разных контекстах и теперь всё будет работать.
$(Button, [btnOne], context);
$(Button, [btnTwo], context2);
$(Button, [btnThree]);
`),
        text('Обратите внимание, на то что мы определили одну из кнопок в анонимном контексте. Вид контекста в данном случае не имеет решающей роли, главное чтобы у них была разная область хранения.'),
        
        alertBlock(
            text('Настоятельно НЕ рекомендуется использовать такой подход в формате функциональных контейнеров! С расширением вашего проекта вам будет гораздо тяжелее следить за переданным контекстом!')
        ),

        text('Так же к минусам такого подхода мы можем еще отметить невозможность передать данные, которые должны быть получены кроме данных в контроллере. А вот где всё построенно на такой реализации, но с возможностями удобной и правильной работы, вы можете увидеть в следующем разделе.'),
    );
}