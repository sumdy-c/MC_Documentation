const ComponentBlock = () => {
    return $('<div>').addClass('doc_content_wrapper').append(
        title('Компоненты: Начало работы'),
        text('В прошлом разделе мы уже успели ознакомится с модулированием. Это действительно удобно в формате разработки, но как говорилось ранее функциональные контейнеры не проектировались с позиции такого применения.'),
        text('Напротив, когда мы говорим о реализации Компонента, мы не способны даже организовать его работу - вне модуля. Давайте сразу посмотри на создание структуры простого компонента.'),

        codeBlock(
`class Example extends MC {
    constructor() {
        super();
    };

    render() {
        return $('&lt;div&gt;').html('Я компонент!');
    }
};

$(Example, 'example_key');`),

        text('Давайте теперь подробнее рассмотрим структуру которую мы тут видим.'),
        text('Мы создали класс и наследовали его от MC, после этого вызвали конструктор этого класса и сразу конструктор super(), далее мы создали метод render() - где по принципам функциональных контейнеров вернули наш jQuery код.'),
        text('Позже мы использовали наш компонент в нашем коде jQuery и передали ему его ключ'),

        alertBlock(
            text('MC не будет вызвать ошибку на отсутствие ключа, поскольку в редких случаях его можно не передавать. Но зачастую вы потерпите неудачу при попытке получения информации от вашего конктретного компонента. Передача уникального ключа гарантирует сохранения вашей области видимости для каждого использованого компонента!')
        ),

        text('Давайте перед тем как начнём углубляться в реализацию компонентов немного поговорим о приципе, на которых строится работа с ними, с точки зрения правильности применения в разных ситуациях.'),
        text('Действительно, зачем нам нужны компоненты когда функциональные контейнеры проще в применении, и не будут требовать следить за уникальными ключами, мы же прямо на месте можем написать контейнер для создания динамики.'),
        text('К ключам мы еще вернёмся, а вот сама логика проектирования контейнеров при их создании была такая:'),
        text('*'),
        text(' - В контейнере вы можете создать свою отдельную область видимости для своих локальных состояний.'),
        text(' - Вы способны переиспользовать контейнеры с разными входящими данными для использования их в разных частях вашего проекта.'),
        text('В этом разделе мы подробно рассмотрим сказанные выше подходы и их применение, но сейчас предлагаю сразу рассмотреть тему создания контейнера - нужно ли всегда следить за ключами которые мы создали ?'),

codeBlock(
    `class Example extends MC {
        constructor() {
            super();
        };
    
        render() {
            return $('&lt;div&gt;').html('Я компонент!');
        }
    };
    
    $(Example, 'example_key');
    // тут мы передали одинаковое значение ключа.
    $(Example, 'example_key');
    `),

        text('Потом мы можем посмотреть в консоль браузера.'),
codeBlock(
`[MC] Обнаружено повторение ключа "example_key" для компонента Example.`
),
        text('Для созданных компонентов, вы получите исключение которое вам расскажет какой ключ повторяется, и вы сможете это исправить.'),
        text('Но, допустим, если вы напишите функцию для генерации уникального значения и будете использовать как ключ, вы получите успешный результат - все будет работать.'),
        text('В реальности вы сильно понизите производительность своего приложения, так как на каждое новое входящее значение MC будет вынужден пересоздавать его virtual.'),
        
        alertBlock(
            text('Не генерируйте ключи на лету, это будет серьёзной ошибкой! Вы можете организовать работу, допустим сгенерировав их один раз ранее.')
        ),

        subTitle('Props'),

        text('Как правило создавая какой-то либо отдельный компонент нам нужно передать в него данные для его построения, давайте посмотрим как мы можем организовать работу с входящими данными:'),

codeBlock(
    `// component.js
    class Component extends MC {
        myLocalState;
        constructor(props) {
            // props как правило есть смысл использовать для инициализации локальных контроллеров
            super();
            // этот контроллер будет изменять этот компонент при изменении. 
            this.myLocalState = super.state(props);
        };

        this.changeLocalState() {
            this.myLocalState.set('Меня опять изменили, теперь при нажатии на кнопку!');
        }
        
        render(states, props) {
            // props есть и тут если это нужно для вас.
            
            const [ state ] = states.global;
            const [ myLocalState ] = states.local;

            return $('&lt;div&gt;').html('Я дополняю важный элемент').append(
                // тут будет такой же текст как и в textPage
                $('&lt;span&gt;').html(state),
                // тут будет такой же текст как и в textPage, но сохранённый и использованный локальным контроллером,
                //  который мы поменяем по нажитию на кнопку ниже
                $('&lt;span&gt;').text(myLocalState),
                $('&lt;button&gt;').on('click', this.changeLocalState),
            );
        }
    };

// myPage.js
    const textPage = 'Я текст в важном элементе';

    const state = MC.createState(textPage);

    setTimeout(() => {
        $('.prettier__text').text('Я поменялся');
        state.set('Я поменялся');
    }, 5000);

    // Возможно, что-то было сделано ранее
    $('#myPage').append(
        $('&lt;div&gt;').addClass('prettier__text').text('Важный элемент').append(
            $('&lt;span&gt;').html(textPage),
            // нас сейчас интересует MC.Props
            $(Component, MC.Props({
                props: textPage,
                states: [state]
            }) 'component_key')
        )
    );`),

        text('Тут довольно много информации, давайте теперь разберём все что тут написано.'),

        text('Давайте начнём с файла myPage.js, тут есть уже какой-то код, и нам было необходимо добавить в него какой-то модуль. По логике его работы, через 5 секунд в селекторе $("<span>") поменяется текст, он так же должен поменяться в нашем новом коде (допустим было такое ТЗ).'),
        text('Самым правильным решением, было записать информацию в контроллер, а потом использовать и заменять уже его. Мы это сделали и создали его: const state = MC.createState(textPage);'),
        text('Далее мы добавили наш компонент и вызвали метод MC.Props, в который мы передали объект, в нём:'),

        text('В props мы передали текст - который был ранее задан ( в textPage ), в states - мы передали наше созданное состояние.'),

        infoBlock(
            text('Обратите внимание, что MC.Props принимает определённый список свойств: props = данные которые вы хотите передать из вне ( any type ), states = массив состояний ( MCstate[] type ) и контекст в который вы хотите поместить компонент ( MCcontext type ).'),
        ),
        
        text('А теперь мы можем посмотреть на файл component.js и разобраться что там происходит:'),
        // text('')
    )
}