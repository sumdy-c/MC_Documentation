const ComponentBlock = () => {
    return $('<div>').addClass('doc_content_wrapper').append(
        title('Компоненты: Начало работы'),
        text('В прошлом разделе мы уже успели ознакомиться с модульностью. Это действительно удобно в формате разработки, но, как говорилось ранее, функциональные контейнеры не проектировались с позиции такого применения.'),
        text('Напротив, когда мы говорим о реализации компонента, мы даже не можем организовать его работу вне модуля. Давайте сразу посмотрим на создание простого компонента.'),

        codeBlock(
`class Example extends MC {
    constructor() {
        super();
    };

    render() {
        return $('&lt;div&gt;').html('Я компонент!');
    }
};

$.MC(Example, 'example_key');`),

        text("И теперь давайте более подробно рассмотрим структуру, которую мы здесь видим. Мы создали класс и унаследовали его от MC (Micro Component), затем вызвали конструктор этого класса и сразу конструктор super(). Далее мы создали метод render(), где в соответствии с принципами функциональных контейнеров вернули наш код jQuery. Позже мы использовали наш компонент в нашем коде jQuery и передали ему его ключ."),

        alertBlock(
            text('MC (Micro Component) не вызовет ошибку в случае отсутствия ключа, поскольку в редких случаях его можно не передавать. Однако, в большинстве случаев, вы можете столкнуться с неудачей при попытке получения информации от вашего конкретного компонента. Передача уникального ключа гарантирует сохранение вашей области видимости для каждого использованного компонента!')
        ),

        text("Давайте, прежде чем углубляться в реализацию компонентов, немного поговорим о принципах, на которых строится работа с ними, с точки зрения правильности применения в различных ситуациях."),
        text('Действительно, зачем нам нужны компоненты, когда функциональные контейнеры проще в применении и не требуют отслеживания уникальных ключей? Мы можем написать контейнер для создания динамики прямо на месте.'),
        text('Ключи мы еще обсудим, а вот сама логика проектирования контейнеров при их создании была следующей:'),
        text('*'),
        text(' - В контейнере вы можете создать свою отдельную область видимости для своих локальных состояний.'),
        text(' - Вы способны переиспользовать контейнеры с разными входящими данными для использования их в разных частях вашего проекта.'),
        text('В этом разделе мы подробно рассмотрим сказанные выше подходы и их применение, но сейчас предлагаю сразу рассмотреть тему создания контейнера - нужно ли всегда следить за ключами которые мы создали ?'),

codeBlock(
    `class Example extends MC {
        constructor() {
            super();
        };
    
        render() {
            return $('&lt;div&gt;').html('Я компонент!');
        }
    };
    
    $.MC(Example, 'example_key');
    // тут мы передали одинаковое значение ключа.
    $.MC(Example, 'example_key');
    `),

        text('Потом мы можем посмотреть в консоль браузера.'),
codeBlock(
`[MC] Обнаружено повторение ключа "example_key" для компонента Example.`
),
        text('Для созданных компонентов, вы получите исключение которое вам расскажет какой ключ повторяется, и вы сможете это исправить.'),
        text('Но, допустим, если вы напишите функцию для генерации уникального значения и будете использовать как ключ, вы получите успешный результат - все будет работать.'),
        text('В реальности вы сильно понизите производительность своего приложения, так как на каждое новое входящее значение MC будет вынужден пересоздавать его virtual.'),
        
        alertBlock(
            text('Не генерируйте ключи на лету, это будет серьёзной ошибкой! Вы можете организовать работу, допустим сгенерировав их один раз ранее.')
        ),

        subTitle('Props'),

        text('Как правило создавая какой-то либо отдельный компонент нам нужно передать в него данные для его построения, давайте посмотрим как мы можем организовать работу с входящими данными:'),

        codeBlock(`// myPage.js
    const textPage = 'Я текст в важном элементе';

    const state = MC.createState(textPage);

    setTimeout(() => {
        $('.prettier__text').text('Я поменялся');
        state.set('Я поменялся');
    }, 5000);

    // Возможно, что-то было сделано ранее
    $('#myPage').append(
        $('&lt;div&gt;').addClass('prettier__text').text('Важный элемент').append(
            $('&lt;span&gt;').html(textPage),
            // нас сейчас интересует MC.Props
            $.MC(Component, MC.Props({
                props: textPage,
                states: [state]
            }) 'component_key')
        )
    );
    `),

        codeBlock(
    `// component.js
    class Component extends MC {
        myLocalState;
        constructor(props, context) {
            // props как правило есть смысл использовать для инициализации локальных контроллеров
            // context нужен для целей организации хранения, он пока вне примера
            super();
            // этот контроллер будет изменять этот компонент при изменении. 
            this.myLocalState = super.state(props);
        };

        this.changeLocalState() {
            this.myLocalState.set('Меня изменили, при нажатии на кнопку!');
        }
        
        render(states, props) {
            // props есть и тут если это нужно для вас.
            
            const [ state ] = states.global;
            const [ myLocalState ] = states.local;

            return $('&lt;div&gt;').html('Я дополняю важный элемент').append(
                // тут будет такой же текст как и в textPage
                $('&lt;span&gt;').html(state),
                // тут будет такой же текст как и в textPage, но сохранённый и использованный локальным контроллером,
                //  который мы поменяем по нажитию на кнопку ниже
                $('&lt;span&gt;').text(myLocalState),
                $('&lt;button&gt;').on('click', () => this.changeLocalState()),
            );
        }
    };`),

        text('Довольно много информации, давайте теперь разберём все что тут написано.'),

        text('Начнём с файла myPage.js:'),
        text('Тут есть уже какой-то код и нам было необходимо добавить в него какой-то модуль. По логике его работы, через 5 секунд в селекторе $("<span>") поменяется текст, он так же должен поменяться в нашем новом коде (допустим было такое ТЗ).'),
        text('Самым правильным решением, было записать информацию в контроллер, а потом использовать и заменять уже его. Мы это сделали и создали его: const state = MC.createState(textPage);'),
        text('Далее мы добавили наш компонент и вызвали метод MC.Props, в который мы передали объект, в нём:'),

        text('В props мы передали текст - который был ранее задан ( в textPage ), в states - мы передали наше созданное состояние.'),

        infoBlock(
            text('Обратите внимание, что MC.Props принимает определённый список свойств: props = данные которые вы хотите передать из вне ( any type ), states = массив состояний ( MCstate[] type ) и контекст в который вы хотите поместить компонент ( MCcontext type ). Используйте параметры по необходимости, они все являются необязательными.'),
        ),
        
        text('А теперь мы можем посмотреть на файл component.js и разобраться что там происходит:'),
        text('Как мы уже с вами делали - мы создали класс, наследовали его от MC и вызвали super(). Далее мы создали свойство в классе myLocalState. Так же мы создали метод changeLocalState и наконец метод render где мы вернули на jQuery код.'),
        text('В методе render мы с вами можем увидеть что он принял определённые параметры, мы вернёмся к ним немногим позже, сейчас давайте разберёмся с локальными и глобальными контроллерами, а так же подробнее рассмотрим наш конструктор.'),
        subTitle('Локальный контроллер'),
        text('Если вспомнить что делает контроллер, мы можем сказать - при привязке контроллера к зависимости контейнера, он обновит наш контейнер.'),
        text('По сути такая же логика проследуется и в компонентах - только теперь мы включаем в зависимость 2 вида контроллеров, - локальный и глобальный.'),
        text('Создание глобального объекта контроллера не поменялось, мы абсолютно так же его создаём с помощью "createState()", но привязка будет организована через "MC.Props({ states: [] })", как только мы его туда передадим, он начнёт просмотр за этим компонентом.'),
        text('Создание же локального объекта контроллера уже имеет другой вид создания - "super.state(value)", то есть от наследованного класса MC, мы вызываем метод "state()". Привязка этого контроллёра уже будет интереснее, ведь он будет изменять "render()" в нашем компоненте сразу же. Без дополнительных манипуляций.'),
        text('Теперь когда мы знаем как формируются контроллеры, давайте получим их значение. В примере выше в методе render мы могли уже наблюдать параметр с названием state, это то что нам нужно!'),
        text('state - объект, который содержит в себе 2 свойства: global - вернёт массив значений глобальных состояний, local - вернёт массив значений локальных состояний.'),
        text('Теперь как мы можем видеть в контрукторе нашего класса Component, мы создали локальное состояние myLocalState и инициализировали его с помощью props. Разумеется мы можем передать в него любое значение, как и с обычным контроллером.'),
        text('Вторым параметром в нашем контрукторе будет контекст, с ним мы разберёмся немного позже.'),
        subTitle('render'),
        text('Теперь мы можем внимательно посмотреть на метод "render()":'),

        alertBlock(
            text('Обратите внимание что название метода должно быть именно "render", так как Мicro Component пытается его найти для формирования HTML'),
        ),

        text('Как уже говорилось ранее, он получит 2 параметра (state,props), и должен отдать jQuery код, но стоит более внимательно рассмотреть возможности которые нам открываются при использовании такого подхода, ведь теперь мы можем определить методы которые нужны для работы конкретного компонента.'),

        text('Посмотрите внимательно на реализацию изменения локального состояния из нашего примера, там мы определили метод "changeLocalState()", таким образом мы можешь отделить не только логику и отображение, но и убирать конкретные действия компонентов самих в себя - достаточно эффективным образом.'),

        title('Пример организации компонентов'),

        text('С подходом формирования компонентов, мы можем организовать вполне понятную и оптимизированную структуру для наших компонентов.'),
        
        text('Предлагаю, посмотреть на пример ниже:'),

        codeBlock(
`//my-app.js
const title = 'Часть моего веб-приложения';
const myContext = MC.createContext();
const theme = MC.createState('ligth');
const openAside = MC.createState(false);

$('#wrapper').append(
    $.MC(Header, MC.Props({
        props: {
            text: title,
            // Обратите внимание, если вы хотите изменить контроллер, но не сам компонент, передайте его в props.
            open: openAside
        },
        state: [theme],
        context: myContext      
    }), 'header'),
    $.MC(Aside, MC.Props({
        state: [theme, openAside],
        context: myContext      
    }), 'aside'),
    $.MC(Main, MC.Props({
        props: title,
        state: [theme],
        context: myContext      
    }), 'main')
);`
        ),

        text('Давайте пойдем по порядку и рассмотрим каждый файл. ( Пожалуйста, имейте ввиду что это демонстрационный сокращенный пример, и главное тут показать принципы работы ):'),
        codeBlock(
`// Header.js
class Header extends MC {
    constructor() {
        super();
    }

    render(state, props) {
        const [ theme ] = state.global;
        return $('&lt;header&gt;').addClass(theme === 'ligth' ? ? 'header-ligth' : 'header-dark').append(
            $('&lt;button&gt;').text('Открыть боковую панель').on('click', () => {
                // Изменение не будет вызывать обновление этого компонента
                props.open.set(!props.open.get());
            }),
            $('&lt;span&gt;').text(props.text)
        )
    }
}
`
        ),

        text('Тут главное обратить внимание, как мы используем глобальное состояние. Мы отдали его не в states, а в props - чтобы избежать изменения в Header. Далее мы меняем его на кнопку, которая должна открывать или закрывать боковую панель.'),
        
codeBlock(
`// Aside.js
class Aside extends MC {
    buttons;
    constructor() {
        super();
        this.buttons = super.state([
            {
                title: 'Кнопка1',
                onClick: () => this.buttonClick(1)
            },
            {
                title: 'Кнопка2',
                onClick: () => this.buttonClick(2)
            },
            {
                title: 'Кнопка3',
                onClick: () => this.buttonClick(3)
            },
        ])
    };

    buttonClick(num) {
        console.log('Вы нажали на кнопку ' + num);
        const newButtons = this.buttons.get();
        const newNum = (newButtons.length + 2);
        newButtons.push({
            title: 'Кнопка' + newNum
            onClick: () => this.buttonClick(newNum);
        });
        this.buttons.set(newButtons);
    };

    render(state, props) {
        const [ theme, open ] = state.global;
        const [ buttons ] = state.local;

        if(!open) {
            return null;
        };

        return $('&lt;aside&gt;').addClass(theme === 'ligth' ? 'aside__panel-ligth' : 'aside__panel-ligth').append(
            buttons.map((btn) => {
                return $('&lt;button&gt;').text(btn.title).on('click', () => btn.onClick());
            })
        )

    };
}`),
        text('Тут нам было бы интересно посмотреть на работу кнопок. Мы создаём их из локального состояния, поэтому мы можем динамически добавлять любое их количество. (в примере, добавляется новая кнопка по нажатию на любую из них).'),

        subTitle('Структуры компонентов'),

        text('Мы еще не имели дел ни с одной структурой. В целом, это тоже самое что и "Динамические структуры" в Фукнциональных контейнерах, только на лад с компонентами:'),
        codeBlock(
`//Main.js
class Main extends MC {
    // персоны
    persons;
    // параметр включающий выделение пользователей
    viewActive;

    constructor() {
        super();
        this.persons = super.state([]);
        // Обратите внимание как мы создаём данный контроллер, ниже мы подробно рассмотрим почему так было сделано
        this.viewActive = MC.createState(false);
        this.getPerson();
    };

    getPerson() {
        $.ajax('example_url').done((data) => {
            persons.set(data);
        });
    };

    viewActivePerson() {
        this.viewActive.set(!this.viewActive.get());
    };

    render(state, props) {
        const [ theme ] = state.global;
        const [ persons ] = state.local;

        $('&lt;main&gt;').addClass(theme === 'ligth' ? 'main__ligth' : 'main__dark').append(
            $('&lt;span&gt;').text(props),
            $('&lt;ul&gt;').append(
                persons.map((person, iter) => {
                    return $.MC(Person, MC.Props({
                        props: person,
                        states: [this.viewActive]
                        // Ключи всегда будут одинаковыми, в таком варианте они останутся оптимизированными.
                    }), \`person\${iter}\`)
                })
            ),
            $('&lt;div&gt;').addClass('theme === 'ligth' ? 'main__panel-ligth' : 'main__panel-dark').append(
                $('&lt;button&gt;').text('Обновить пользователей').on('click', () => this.getPerson()),
                $('&lt;button&gt;').text('Выделить/снять выделение активных пользователей').on('click', () => this.viewActivePerson()),
            )
        )
    }
};`
        ),

        text('Почти всё что тут было применено и рассмотрено ранее за исключением 2 вещей. Первое - это создание контроллера в компоненте, методом создания глобального контроллера.'),
        text('Дело в уже известном нам принципе привязки к компоненту. Локальный контроллер всегда будет обновлять компонент в котором он создан, но если нам нужно обновить только дочерний компонент(ы), мы можем создать глобальный контроллер непосрественно в конструкторе родителя и манипулировать уже им. Родитель в таком случае к нему привязан не будет.'),
        text('Важным является еще то, что если вам нужно вызвать обновление родителя в ребёнке через локальный контроллер родителя, вы можете просто отдать его в props дочернего элемента, а там уже вызвать .set().'),
        alertBlock(
            text('Как правило использование локальной зависимости компонента, в states его детей - это ошибка. Такая привязка нарушит порядок обновления. Настоятельно рекомендуется избегать таких ситуации.')
        ),
        text('Второе, это появление дочернего компонента в целом, это и будет называтся нашей структурой компонентов.'),
        text('Как правило вы будете собирать вашу страницу из таких компонентов, создавая при этом цельную структуру которую будет гораздо проще в последствии поддерживать. Давайте посмотрим, что в нашем Person:'),

        codeBlock(
`//Person.js
class Person extends MC {
    constructor(props) {
        super();
    };

    render(state, props) {
        // обратите внимание, что мы достали его из global;
        const [ viewActive ] = state.global;

        // Тут мы посмотрим, если пользователь активный и флаг выделения включен, присвоим другой css класс
        return $('&lt;div&gt;').addClass(props.active && viewActive ? 'person__active' : 'person').append(
            $('&lt;span&gt;').text(props.name),
            $('&lt;span&gt;').text(props.phone),
            $('&lt;span&gt;').text(props.age),
        )
    }
};`
        ),

        text('Как вы видите, ничего особенного в таких компонентах нет, и это хорошо. Такое построение помогает поддерживать слабую связанность компонентов друг с другом, организовать их оптимизированое обновление, переиспользовать их в любых других компонентах, использовать по несколько раз с разными параметрами и наконец поддерживать единый вид их создания.'),

        title('Использование Функциональных контейнеров и Компонентов'),

        text('Теперь когда мы знакомы, и с Функциональными контейнерами, и Компонентами, а главное умеем их использовать - нужно поговорить как мы можем объединить эти знания, и что при этом нужно учитывать.'),
        text('Сразу попробуем реализовать такой подход:'),

        codeBlock(
`$(() => {
    // Как уже говорилось ранее функция должна отдать код jQuery.
    return $('&lt;div&gt;').append(
        $.MC(Example, 'example')
    )
}, [])        
`),
        text('Если бы мы не обернули наш Example (<div>) элементом, мы бы потеряли область контроля, то есть элемент - который должен контролироваться данным функциональный контейнером.'),
        infoBlock(
            text('Функциональный контейнер или Классовый компонент Micro Component - должны контролировать часть HTML.')
        ),

        text('Это правило работает так же в другую сторону. Вы не можете первым элементом в классовом компоненте, отдать функциональный контейнер. Оберните в элемент, если есть потребность в таком поведении.'),

        text('Так же стоит обратить внимание, что такой контейнер в классовом комопненте будет проигрывать дочернему классовому компоненту по функциональности, т.к. при попытке обновить его элементы которые не являются состоянием, вы потерпите неудачу, вы уже знаете способ как можно обойти это поведение, но ниже будет оставлен пример.'),

        codeBlock(
`class Example extends MC {
    local_name;
    constructor() {
        super();
        this.local_name = super.state('TEST');
    }

    render() {
        return $('&lt;div&gt;').append(
            $.MC((state) => {
                const text_fc = this.local_name.get();
                return $('&lt;div&gt;').text(text_fc);
                // Если мы запишем в зависимость this.local_name, мы потеряем правильную последовательность обновления,
                // используйте MC.createState() при необходимости.
            }, []),
            $('&lt;button&gt;').text('Изменить').on('click', () => this.local_name.set(Date.now()))
        )
    };
};
`
        ),

        text('Стоит отметить, что на примере выше показана частью неверная реализация. Поскольку нам нужно менять текст только внутри Функционального контейнера, мы могли бы создать контроллер с помощью MC.createState() и менять его по нажатию на кнопку. Сам контроллер поместить зависимостью в функциональный контейнер, таким образом мы бы миновали лишнее вхождение в компонент Example.'),
        
        infoBlock(
            text('На этом мы заканчиваем нашу работу с компонентами. Пока библиотека в демонстрационном режиме, но если вам понравилось знакомство с Micro Component - разработчик будет очень признателен за поддержку на GitHub в виде звезды! Спасибо за это путешествие по изучению Micro Component, надеюсь применение инструмента принесёт вам только позитивный опыт кодирования. Успехов!')
        )
    )
};